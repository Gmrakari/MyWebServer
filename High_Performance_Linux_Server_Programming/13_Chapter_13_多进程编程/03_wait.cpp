

/*
 * Date:2021-05-06 21:02
 * filename:03_wait.cpp
 *
 */

/*
 *
僵尸进程

对于多进程程序而言，父进程一般需要跟踪子进程的退出状态。
因此，当子进程结束运行时，内核不会立即释放该进程的进程表表项，以满足父进程后续对该子进程退出信息的查询
另外一种使子进程进入僵尸态的情况是：
父进程结束或者异常终止，而子进程继续运行。此时子进程的PPID将被操作系统设置为1，即init进程。
init进程接管了该子进程，并等待它结束。在父进程退出之后，子进程退出之前，该子进程处于僵尸态

无论哪种情况，如果父进程没有正确地处理子进程地返回信息，子进程都将停留在僵尸态，并占据着内核资源

下面这对函数地父进程中调用，以等待子进程地结束，并获取子进程地返回信息，从而避免了僵尸进程的产生，
或者使子进程的僵尸态立即结束


*/

#include <sys/types.h>
#include <sys/wait.h>
pid_t wait(int* stat_loc);
pid_t waitpid(pid_t pid,int* stat_loc,int options);

//wait函数将阻塞进程，直到该进程的某个子进程结束运行为止。它返回结束运行的子进程的PID
//并将子进程的退出状态信息存储于stat_loc参数指向的内存中。

//waitpid函数我们最好在某个子进程退出之后再调用它。
//那么父进程从何得知某个子进程已经退出了呢？
//SIGCHLD信号的用途--当一个进程结束时，它将给其父进程发送一个SIGCHLD信号。
//因为，我们可以在父进程中捕获SIGCHLD信号，并在信号处理函数中调用waitpid函数以"彻底结束"一个子进程

static void handle_child(int sig)
{
	pid_t pid;
	int stat;
	while((pid == waitpid(-1,&stat,WNOHANG)) > 0)
	{
		/* 对结束的子进程进行善后处理 */
	}
}
